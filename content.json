{"meta":{"title":"熊峰的博客 - Seifon's Blog","subtitle":"不定期分享一些个人开发经验","description":"Java开发","author":"Seifon","url":"http://www.seifon.cn"},"pages":[{"title":"","date":"2018-01-24T16:06:48.000Z","updated":"2018-01-24T15:13:45.000Z","comments":true,"path":"404.html","permalink":"http://www.seifon.cn/404.html","excerpt":"","text":""},{"title":"关于我","date":"2017-09-09T18:11:09.000Z","updated":"2018-04-27T16:05:54.000Z","comments":false,"path":"about/index.html","permalink":"http://www.seifon.cn/about/index.html","excerpt":"","text":"我是一名JAVA开发人员，以后会不定期给大家整理并分享工作当中自己的遇到的一些难题和一些开发经验，希望能够得到大家的支持和肯定，谢谢！ GitHub: https://github.com/Seifon Email: seifon@126.com 微信公众号："},{"title":"分类","date":"2017-09-09T18:10:26.000Z","updated":"2018-01-24T15:13:45.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.seifon.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-09-09T18:09:11.000Z","updated":"2018-01-24T15:13:45.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.seifon.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring统一返回Json工具类，带分页信息","slug":"Spring统一返回Json工具类，带分页信息","date":"2018-04-30T12:37:00.000Z","updated":"2018-06-05T14:41:13.000Z","comments":true,"path":"2018/04/30/Spring统一返回Json工具类，带分页信息/","link":"","permalink":"http://www.seifon.cn/2018/04/30/Spring统一返回Json工具类，带分页信息/","excerpt":"","text":"前言： 项目做前后端分离时，我们会经常提供Json数据给前端，如果有一个统一的Json格式返回工具类，那么将大大提高开发效率和减低沟通成本。 此Json响应工具类，支持带分页信息，支持泛型，支持HttpStatus标准返回码 效果预览： 步入正题：1. Resp工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249import java.io.Serializable;import java.util.Map;/** * @Author: XiongFeng * @Description: Restful统一Json响应对象封装 * @Date: Created in 9:39 2018/4/10 */public class Resp&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = 1L; private final static String SUCCESS_CODE = &quot;200&quot;; /** * 返回状态码 */ private String status; /** * 返回消息 */ private String message; /** * 返回内容 */ private T data; /** * 分页信息 */ private PageInfo page; /** * 其他内容 */ private Map&lt;String, Object&gt; ext; public String getStatus() &#123; return status; &#125; public void setStatus(String status) &#123; this.status = status; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public Map&lt;String, Object&gt; getExt() &#123; return ext; &#125; public void setExt(Map&lt;String, Object&gt; ext) &#123; this.ext = ext; &#125; public PageInfo getPage() &#123; return page; &#125; public void setPage(PageInfo page) &#123; this.page = page; &#125; public Resp()&#123; this.status = SUCCESS_CODE; this.message = &quot;SUCCESS&quot;; &#125; public Resp(String status, String message) &#123; this.status = status; this.message = message; &#125; public Resp(String status, String message, T data) &#123; this.status = status; this.message = message; this.data = data; &#125; public Resp(String status, String message, T data, Map&lt;String, Object&gt; ext) &#123; this.status = status; this.message = message; this.data = data; this.ext = ext; &#125; public Resp(String status, String message, T data, PageInfo pageInfo) &#123; this.status = status; this.message = message; this.data = data; this.page = pageInfo; &#125; public Resp(String status, String message, T data, Map&lt;String, Object&gt; ext, PageInfo pageInfo) &#123; this.status = status; this.message = message; this.data = data; this.ext = ext; this.page = pageInfo; &#125; public Resp(String status, String message, T data, Long total, Integer pageNo, Integer pageSize)&#123; PageInfo pageInfo = new PageInfo(total, pageNo, pageSize); this.status = status; this.message = message; this.data = data; this.page = pageInfo; &#125; public Resp(String status, String message, T data, Map&lt;String, Object&gt; ext, Long total, Integer pageNo, Integer pageSize)&#123; PageInfo pageInfo = new PageInfo(total, pageNo, pageSize); this.status = status; this.message = message; this.data = data; this.ext = ext; this.page = pageInfo; &#125; //快速返回成功 public static &lt;T&gt;Resp success()&#123; return new Resp&lt;T&gt;(SUCCESS_CODE,&quot;请求成功&quot;,null); &#125; public static &lt;T&gt;Resp success(T result)&#123; return new Resp&lt;T&gt;(SUCCESS_CODE,&quot;请求成功&quot;,result); &#125; public static &lt;T&gt;Resp success(String message, T result)&#123; return new Resp&lt;T&gt;(SUCCESS_CODE,message,result); &#125; public static &lt;T&gt;Resp success(String message, T result, Map&lt;String, Object&gt; extra)&#123; return new Resp&lt;T&gt;(SUCCESS_CODE,message,result, extra); &#125; public static &lt;T&gt;Resp success(T result, Long total, Integer pageNo, Integer pageSize)&#123; PageInfo pageInfo = new PageInfo(total, pageNo, pageSize); return new Resp&lt;T&gt;(SUCCESS_CODE,&quot;请求成功&quot;,result, pageInfo); &#125; public static &lt;T&gt;Resp success(T result, Map&lt;String, Object&gt; extra, Long total, Integer pageNo, Integer pageSize)&#123; PageInfo pageInfo = new PageInfo(total, pageNo, pageSize); return new Resp&lt;T&gt;(SUCCESS_CODE,&quot;请求成功&quot;,result, extra,pageInfo); &#125; public static &lt;T&gt;Resp success(String message, T result, Long total, Integer pageNo, Integer pageSize)&#123; PageInfo pageInfo = new PageInfo(total, pageNo, pageSize); return new Resp&lt;T&gt;(SUCCESS_CODE,message,result,pageInfo); &#125; public static &lt;T&gt;Resp success(String message, T result, Map&lt;String, Object&gt; extra, Long total, Integer pageNo, Integer pageSize)&#123; PageInfo pageInfo = new PageInfo(total, pageNo, pageSize); return new Resp&lt;T&gt;(SUCCESS_CODE,message,result, extra,pageInfo); &#125; //快速返回失败状态 public static &lt;T&gt;Resp fail()&#123; return new Resp&lt;T&gt;(ErrorCode.SYSTEM_ERROR.getCode(),ErrorCode.SYSTEM_ERROR.getMessage()); &#125; public static &lt;T&gt;Resp fail(T result)&#123; return new Resp&lt;T&gt;(ErrorCode.SYSTEM_ERROR.getCode(),ErrorCode.SYSTEM_ERROR.getMessage(),result); &#125; public &lt;T&gt;Resp fail(String message, T result)&#123; return new Resp&lt;T&gt;(ErrorCode.SYSTEM_ERROR.getCode(),message,result); &#125; public &lt;T&gt;Resp fail(String message, T result, Map&lt;String, Object&gt; extra)&#123; return new Resp&lt;T&gt;(ErrorCode.SYSTEM_ERROR.getCode(),message,result, extra); &#125; public static &lt;T&gt;Resp fail(ErrorCode errorCode)&#123; return new Resp&lt;T&gt;(errorCode.getCode(),errorCode.getMessage()); &#125; public static &lt;T&gt;Resp fail(ErrorCode errorCode, T result)&#123; return new Resp&lt;T&gt;(errorCode.getCode(),errorCode.getMessage(),result); &#125; public static &lt;T&gt;Resp fail(ErrorCode errorCode, String message, T result)&#123; return new Resp&lt;T&gt;(errorCode.getCode(),message,result); &#125; public static &lt;T&gt;Resp fail(ErrorCode errorCode, String message, T result, Map&lt;String, Object&gt; extra)&#123; return new Resp&lt;T&gt;(errorCode.getCode(),message,result, extra); &#125; //快速返回自定义状态码 public static &lt;T&gt;Resp result(String statusCode, String message)&#123; return new Resp&lt;T&gt;(statusCode,message); &#125; public static &lt;T&gt;Resp result(String statusCode, String message, T result)&#123; return new Resp&lt;T&gt;(statusCode,message,result); &#125; public static &lt;T&gt;Resp result(String statusCode, String message, T result, Map&lt;String, Object&gt; extra)&#123; return new Resp&lt;T&gt;(statusCode,message,result, extra); &#125; public static &lt;T&gt;Resp result(String statusCode, String message, T result, Long total, Integer pageNo, Integer pageSize)&#123; PageInfo pageInfo = new PageInfo(total, pageNo, pageSize); return new Resp&lt;T&gt;(statusCode,message,result, pageInfo); &#125; public static &lt;T&gt;Resp result(String statusCode, String message, T result, Map&lt;String, Object&gt; extra, Long total, Integer pageNo, Integer pageSize)&#123; PageInfo pageInfo = new PageInfo(total, pageNo, pageSize); return new Resp&lt;T&gt;(statusCode,message,result, extra,pageInfo); &#125; //快速返回Http状态 public static &lt;T&gt;Resp httpStatus(HttpStatus httpStatus, String message)&#123; return result(httpStatus.toString(),message); &#125; public static &lt;T&gt;Resp httpStatus(HttpStatus httpStatus, String message, T result)&#123; return result(httpStatus.toString(),message,result); &#125; public static &lt;T&gt;Resp httpStatus(HttpStatus httpStatus, String message, T result, Map&lt;String, Object&gt; extra)&#123; return result(httpStatus.toString(),message,result, extra); &#125; public static &lt;T&gt;Resp httpStatus(HttpStatus httpStatus, String message, T result, Long total, Integer pageNo, Integer pageSize)&#123; PageInfo pageInfo = new PageInfo(total, pageNo, pageSize); return result(httpStatus.toString(),message,result, total, pageNo, pageSize); &#125; public static &lt;T&gt;Resp httpStatus(HttpStatus httpStatus, String message, T result, Map&lt;String, Object&gt; extra, Long total, Integer pageNo, Integer pageSize)&#123; PageInfo pageInfo = new PageInfo(total, pageNo, pageSize); return result(httpStatus.toString(),message,result, extra, total, pageNo, pageSize); &#125;&#125; 2. PageInfo 用于封装分页信息的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.Serializable;/** * @Author: XiongFeng * @Description: 分页信息 * @Date: Created in 9:39 2018/4/10 */public class PageInfo implements Serializable&#123; private static final long serialVersionUID = 1L; /** * 总记录数 */ private Long total; /** * 总页数 */ private Long totalPages; /** * 当前页 */ private Integer pageNo; /** * 页记录数 */ private Integer pageSize; public PageInfo(Long total) &#123; this.total = total; &#125; public PageInfo(Long total, Integer pageNo, Integer pageSize) &#123; this.total = total; this.totalPages = (total - 1) / pageSize + 1; this.pageNo = pageNo; this.pageSize = pageSize; &#125; public static PageInfo page(Long total) &#123; return new PageInfo(total); &#125; public static PageInfo page( Long total, Integer pageNo, Integer pageSize) &#123; return new PageInfo(total, pageNo, pageSize); &#125; public Long getTotal() &#123; return total; &#125; public void setTotal(Long total) &#123; this.total = total; &#125; public Long getTotalPages() &#123; return totalPages; &#125; public void setTotalPages(Long totalPages) &#123; this.totalPages = totalPages; &#125; public Integer getPageNo() &#123; return pageNo; &#125; public void setPageNo(Integer pageNo) &#123; this.pageNo = pageNo; &#125; public Integer getPageSize() &#123; return pageSize; &#125; public void setPageSize(Integer pageSize) &#123; this.pageSize = pageSize; &#125;&#125; 4. ErrorCode 用于定义错误码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @Author: XiongFeng * @Description: 错误码 * @Date: Created in 9:39 2018/4/10 */public enum ErrorCode &#123; SYSTEM_ERROR(500, &quot;系统错误&quot;), PARAMETER_CHECK_ERROR(400, &quot;参数校验错误&quot;), AUTH_VALID_ERROR(701, &quot;用户权限不足&quot;), UNLOGIN_ERROR(401, &quot;用户未登录或登录状态超时失效&quot;), ; private final Integer value; private final String message; ErrorCode(int value, String message) &#123; this.value = value; this.message = message; &#125; public int getValue() &#123; return value; &#125; public String getMessage() &#123; return message; &#125; @Override public String toString() &#123; return value.toString(); &#125; public String getCode() &#123; return value.toString(); &#125; public static ErrorCode getByCode(Integer value) &#123; for (ErrorCode _enum : values()) &#123; if (_enum.getValue() == value) &#123; return _enum; &#125; &#125; return null; &#125;&#125; 5. HttpStatus 提取自org.springframework.http,可以自己引入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523/** * Enumeration of HTTP status codes. * * &lt;p&gt;The HTTP status code series can be retrieved via &#123;@link #series()&#125;. * * @author Arjen Poutsma * @author Sebastien Deleuze * @author Brian Clozel * @since 3.0 * @see HttpStatus.Series * @see &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;HTTP Status Code Registry&lt;/a&gt; * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/List_of_HTTP_status_codes&quot;&gt;List of HTTP status codes - Wikipedia&lt;/a&gt; */public enum HttpStatus &#123; // 1xx Informational /** * &#123;@code 100 Continue&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.2.1&quot;&gt;HTTP/1.1: Semantics and Content, section 6.2.1&lt;/a&gt; */ CONTINUE(100, &quot;Continue&quot;), /** * &#123;@code 101 Switching Protocols&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.2.2&quot;&gt;HTTP/1.1: Semantics and Content, section 6.2.2&lt;/a&gt; */ SWITCHING_PROTOCOLS(101, &quot;Switching Protocols&quot;), /** * &#123;@code 102 Processing&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc2518#section-10.1&quot;&gt;WebDAV&lt;/a&gt; */ PROCESSING(102, &quot;Processing&quot;), /** * &#123;@code 103 Checkpoint&#125;. * @see &lt;a href=&quot;http://code.google.com/p/gears/wiki/ResumableHttpRequestsProposal&quot;&gt;A proposal for supporting * resumable POST/PUT HTTP requests in HTTP/1.0&lt;/a&gt; */ CHECKPOINT(103, &quot;Checkpoint&quot;), // 2xx Success /** * &#123;@code 200 OK&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.3.1&quot;&gt;HTTP/1.1: Semantics and Content, section 6.3.1&lt;/a&gt; */ OK(200, &quot;OK&quot;), /** * &#123;@code 201 Created&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.3.2&quot;&gt;HTTP/1.1: Semantics and Content, section 6.3.2&lt;/a&gt; */ CREATED(201, &quot;Created&quot;), /** * &#123;@code 202 Accepted&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.3.3&quot;&gt;HTTP/1.1: Semantics and Content, section 6.3.3&lt;/a&gt; */ ACCEPTED(202, &quot;Accepted&quot;), /** * &#123;@code 203 Non-Authoritative Information&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.3.4&quot;&gt;HTTP/1.1: Semantics and Content, section 6.3.4&lt;/a&gt; */ NON_AUTHORITATIVE_INFORMATION(203, &quot;Non-Authoritative Information&quot;), /** * &#123;@code 204 No Content&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.3.5&quot;&gt;HTTP/1.1: Semantics and Content, section 6.3.5&lt;/a&gt; */ NO_CONTENT(204, &quot;No Content&quot;), /** * &#123;@code 205 Reset Content&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.3.6&quot;&gt;HTTP/1.1: Semantics and Content, section 6.3.6&lt;/a&gt; */ RESET_CONTENT(205, &quot;Reset Content&quot;), /** * &#123;@code 206 Partial Content&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7233#section-4.1&quot;&gt;HTTP/1.1: Range Requests, section 4.1&lt;/a&gt; */ PARTIAL_CONTENT(206, &quot;Partial Content&quot;), /** * &#123;@code 207 Multi-Status&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc4918#section-13&quot;&gt;WebDAV&lt;/a&gt; */ MULTI_STATUS(207, &quot;Multi-Status&quot;), /** * &#123;@code 208 Already Reported&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc5842#section-7.1&quot;&gt;WebDAV Binding Extensions&lt;/a&gt; */ ALREADY_REPORTED(208, &quot;Already Reported&quot;), /** * &#123;@code 226 IM Used&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc3229#section-10.4.1&quot;&gt;Delta encoding in HTTP&lt;/a&gt; */ IM_USED(226, &quot;IM Used&quot;), // 3xx Redirection /** * &#123;@code 300 Multiple Choices&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.4.1&quot;&gt;HTTP/1.1: Semantics and Content, section 6.4.1&lt;/a&gt; */ MULTIPLE_CHOICES(300, &quot;Multiple Choices&quot;), /** * &#123;@code 301 Moved Permanently&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.4.2&quot;&gt;HTTP/1.1: Semantics and Content, section 6.4.2&lt;/a&gt; */ MOVED_PERMANENTLY(301, &quot;Moved Permanently&quot;), /** * &#123;@code 302 Found&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.4.3&quot;&gt;HTTP/1.1: Semantics and Content, section 6.4.3&lt;/a&gt; */ FOUND(302, &quot;Found&quot;), /** * &#123;@code 302 Moved Temporarily&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;HTTP/1.0, section 9.3&lt;/a&gt; * @deprecated in favor of &#123;@link #FOUND&#125; which will be returned from &#123;@code HttpStatus.valueOf(302)&#125; */ @Deprecated MOVED_TEMPORARILY(302, &quot;Moved Temporarily&quot;), /** * &#123;@code 303 See Other&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.4.4&quot;&gt;HTTP/1.1: Semantics and Content, section 6.4.4&lt;/a&gt; */ SEE_OTHER(303, &quot;See Other&quot;), /** * &#123;@code 304 Not Modified&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;HTTP/1.1: Conditional Requests, section 4.1&lt;/a&gt; */ NOT_MODIFIED(304, &quot;Not Modified&quot;), /** * &#123;@code 305 Use Proxy&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.4.5&quot;&gt;HTTP/1.1: Semantics and Content, section 6.4.5&lt;/a&gt; * @deprecated due to security concerns regarding in-band configuration of a proxy */ @Deprecated USE_PROXY(305, &quot;Use Proxy&quot;), /** * &#123;@code 307 Temporary Redirect&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.4.7&quot;&gt;HTTP/1.1: Semantics and Content, section 6.4.7&lt;/a&gt; */ TEMPORARY_REDIRECT(307, &quot;Temporary Redirect&quot;), /** * &#123;@code 308 Permanent Redirect&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7238&quot;&gt;RFC 7238&lt;/a&gt; */ PERMANENT_REDIRECT(308, &quot;Permanent Redirect&quot;), // --- 4xx Client Error --- /** * &#123;@code 400 Bad Request&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.1&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.1&lt;/a&gt; */ BAD_REQUEST(400, &quot;Bad Request&quot;), /** * &#123;@code 401 Unauthorized&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7235#section-3.1&quot;&gt;HTTP/1.1: Authentication, section 3.1&lt;/a&gt; */ UNAUTHORIZED(401, &quot;Unauthorized&quot;), /** * &#123;@code 402 Payment Required&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.2&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.2&lt;/a&gt; */ PAYMENT_REQUIRED(402, &quot;Payment Required&quot;), /** * &#123;@code 403 Forbidden&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.3&lt;/a&gt; */ FORBIDDEN(403, &quot;Forbidden&quot;), /** * &#123;@code 404 Not Found&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.4&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.4&lt;/a&gt; */ NOT_FOUND(404, &quot;Not Found&quot;), /** * &#123;@code 405 Method Not Allowed&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.5&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.5&lt;/a&gt; */ METHOD_NOT_ALLOWED(405, &quot;Method Not Allowed&quot;), /** * &#123;@code 406 Not Acceptable&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.6&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.6&lt;/a&gt; */ NOT_ACCEPTABLE(406, &quot;Not Acceptable&quot;), /** * &#123;@code 407 Proxy Authentication Required&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7235#section-3.2&quot;&gt;HTTP/1.1: Authentication, section 3.2&lt;/a&gt; */ PROXY_AUTHENTICATION_REQUIRED(407, &quot;Proxy Authentication Required&quot;), /** * &#123;@code 408 Request Timeout&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.7&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.7&lt;/a&gt; */ REQUEST_TIMEOUT(408, &quot;Request Timeout&quot;), /** * &#123;@code 409 Conflict&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.8&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.8&lt;/a&gt; */ CONFLICT(409, &quot;Conflict&quot;), /** * &#123;@code 410 Gone&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.9&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.9&lt;/a&gt; */ GONE(410, &quot;Gone&quot;), /** * &#123;@code 411 Length Required&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.10&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.10&lt;/a&gt; */ LENGTH_REQUIRED(411, &quot;Length Required&quot;), /** * &#123;@code 412 Precondition failed&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7232#section-4.2&quot;&gt;HTTP/1.1: Conditional Requests, section 4.2&lt;/a&gt; */ PRECONDITION_FAILED(412, &quot;Precondition Failed&quot;), /** * &#123;@code 413 Payload Too Large&#125;. * @since 4.1 * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.11&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.11&lt;/a&gt; */ PAYLOAD_TOO_LARGE(413, &quot;Payload Too Large&quot;), /** * &#123;@code 413 Request Entity Too Large&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc2616#section-10.4.14&quot;&gt;HTTP/1.1, section 10.4.14&lt;/a&gt; * @deprecated in favor of &#123;@link #PAYLOAD_TOO_LARGE&#125; which will be returned from &#123;@code HttpStatus.valueOf(413)&#125; */ @Deprecated REQUEST_ENTITY_TOO_LARGE(413, &quot;Request Entity Too Large&quot;), /** * &#123;@code 414 URI Too Long&#125;. * @since 4.1 * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.12&lt;/a&gt; */ URI_TOO_LONG(414, &quot;URI Too Long&quot;), /** * &#123;@code 414 Request-URI Too Long&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc2616#section-10.4.15&quot;&gt;HTTP/1.1, section 10.4.15&lt;/a&gt; * @deprecated in favor of &#123;@link #URI_TOO_LONG&#125; which will be returned from &#123;@code HttpStatus.valueOf(414)&#125; */ @Deprecated REQUEST_URI_TOO_LONG(414, &quot;Request-URI Too Long&quot;), /** * &#123;@code 415 Unsupported Media Type&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.13&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.13&lt;/a&gt; */ UNSUPPORTED_MEDIA_TYPE(415, &quot;Unsupported Media Type&quot;), /** * &#123;@code 416 Requested Range Not Satisfiable&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7233#section-4.4&quot;&gt;HTTP/1.1: Range Requests, section 4.4&lt;/a&gt; */ REQUESTED_RANGE_NOT_SATISFIABLE(416, &quot;Requested range not satisfiable&quot;), /** * &#123;@code 417 Expectation Failed&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.5.14&quot;&gt;HTTP/1.1: Semantics and Content, section 6.5.14&lt;/a&gt; */ EXPECTATION_FAILED(417, &quot;Expectation Failed&quot;), /** * &#123;@code 418 I&apos;m a teapot&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc2324#section-2.3.2&quot;&gt;HTCPCP/1.0&lt;/a&gt; */ I_AM_A_TEAPOT(418, &quot;I&apos;m a teapot&quot;), /** * @deprecated See &lt;a href=&quot;http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=draft-ietf-webdav-protocol-06.txt&quot;&gt;WebDAV Draft Changes&lt;/a&gt; */ @Deprecated INSUFFICIENT_SPACE_ON_RESOURCE(419, &quot;Insufficient Space On Resource&quot;), /** * @deprecated See &lt;a href=&quot;http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=draft-ietf-webdav-protocol-06.txt&quot;&gt;WebDAV Draft Changes&lt;/a&gt; */ @Deprecated METHOD_FAILURE(420, &quot;Method Failure&quot;), /** * @deprecated See &lt;a href=&quot;http://tools.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=draft-ietf-webdav-protocol-06.txt&quot;&gt;WebDAV Draft Changes&lt;/a&gt; */ @Deprecated DESTINATION_LOCKED(421, &quot;Destination Locked&quot;), /** * &#123;@code 422 Unprocessable Entity&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc4918#section-11.2&quot;&gt;WebDAV&lt;/a&gt; */ UNPROCESSABLE_ENTITY(422, &quot;Unprocessable Entity&quot;), /** * &#123;@code 423 Locked&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc4918#section-11.3&quot;&gt;WebDAV&lt;/a&gt; */ LOCKED(423, &quot;Locked&quot;), /** * &#123;@code 424 Failed Dependency&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc4918#section-11.4&quot;&gt;WebDAV&lt;/a&gt; */ FAILED_DEPENDENCY(424, &quot;Failed Dependency&quot;), /** * &#123;@code 426 Upgrade Required&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc2817#section-6&quot;&gt;Upgrading to TLS Within HTTP/1.1&lt;/a&gt; */ UPGRADE_REQUIRED(426, &quot;Upgrade Required&quot;), /** * &#123;@code 428 Precondition Required&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc6585#section-3&quot;&gt;Additional HTTP Status Codes&lt;/a&gt; */ PRECONDITION_REQUIRED(428, &quot;Precondition Required&quot;), /** * &#123;@code 429 Too Many Requests&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc6585#section-4&quot;&gt;Additional HTTP Status Codes&lt;/a&gt; */ TOO_MANY_REQUESTS(429, &quot;Too Many Requests&quot;), /** * &#123;@code 431 Request Header Fields Too Large&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc6585#section-5&quot;&gt;Additional HTTP Status Codes&lt;/a&gt; */ REQUEST_HEADER_FIELDS_TOO_LARGE(431, &quot;Request Header Fields Too Large&quot;), /** * &#123;@code 451 Unavailable For Legal Reasons&#125;. * @see &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-legally-restricted-status-04&quot;&gt; * An HTTP Status Code to Report Legal Obstacles&lt;/a&gt; * @since 4.3 */ UNAVAILABLE_FOR_LEGAL_REASONS(451, &quot;Unavailable For Legal Reasons&quot;), // --- 5xx Server Error --- /** * &#123;@code 500 Internal Server Error&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.6.1&quot;&gt;HTTP/1.1: Semantics and Content, section 6.6.1&lt;/a&gt; */ INTERNAL_SERVER_ERROR(500, &quot;Internal Server Error&quot;), /** * &#123;@code 501 Not Implemented&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.6.2&quot;&gt;HTTP/1.1: Semantics and Content, section 6.6.2&lt;/a&gt; */ NOT_IMPLEMENTED(501, &quot;Not Implemented&quot;), /** * &#123;@code 502 Bad Gateway&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.6.3&quot;&gt;HTTP/1.1: Semantics and Content, section 6.6.3&lt;/a&gt; */ BAD_GATEWAY(502, &quot;Bad Gateway&quot;), /** * &#123;@code 503 Service Unavailable&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.6.4&quot;&gt;HTTP/1.1: Semantics and Content, section 6.6.4&lt;/a&gt; */ SERVICE_UNAVAILABLE(503, &quot;Service Unavailable&quot;), /** * &#123;@code 504 Gateway Timeout&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.6.5&quot;&gt;HTTP/1.1: Semantics and Content, section 6.6.5&lt;/a&gt; */ GATEWAY_TIMEOUT(504, &quot;Gateway Timeout&quot;), /** * &#123;@code 505 HTTP Version Not Supported&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc7231#section-6.6.6&quot;&gt;HTTP/1.1: Semantics and Content, section 6.6.6&lt;/a&gt; */ HTTP_VERSION_NOT_SUPPORTED(505, &quot;HTTP Version not supported&quot;), /** * &#123;@code 506 Variant Also Negotiates&#125; * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc2295#section-8.1&quot;&gt;Transparent Content Negotiation&lt;/a&gt; */ VARIANT_ALSO_NEGOTIATES(506, &quot;Variant Also Negotiates&quot;), /** * &#123;@code 507 Insufficient Storage&#125; * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc4918#section-11.5&quot;&gt;WebDAV&lt;/a&gt; */ INSUFFICIENT_STORAGE(507, &quot;Insufficient Storage&quot;), /** * &#123;@code 508 Loop Detected&#125; * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc5842#section-7.2&quot;&gt;WebDAV Binding Extensions&lt;/a&gt; */ LOOP_DETECTED(508, &quot;Loop Detected&quot;), /** * &#123;@code 509 Bandwidth Limit Exceeded&#125; */ BANDWIDTH_LIMIT_EXCEEDED(509, &quot;Bandwidth Limit Exceeded&quot;), /** * &#123;@code 510 Not Extended&#125; * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc2774#section-7&quot;&gt;HTTP Extension Framework&lt;/a&gt; */ NOT_EXTENDED(510, &quot;Not Extended&quot;), /** * &#123;@code 511 Network Authentication Required&#125;. * @see &lt;a href=&quot;http://tools.ietf.org/html/rfc6585#section-6&quot;&gt;Additional HTTP Status Codes&lt;/a&gt; */ NETWORK_AUTHENTICATION_REQUIRED(511, &quot;Network Authentication Required&quot;); private final int value; private final String reasonPhrase; HttpStatus(int value, String reasonPhrase) &#123; this.value = value; this.reasonPhrase = reasonPhrase; &#125; /** * Return the integer value of this status code. */ public int value() &#123; return this.value; &#125; /** * Return the reason phrase of this status code. */ public String getReasonPhrase() &#123; return this.reasonPhrase; &#125; /** * Whether this status code is in the HTTP series * &#123;@link org.springframework.http.HttpStatus.Series#INFORMATIONAL&#125;. * This is a shortcut for checking the value of &#123;@link #series()&#125;. */ public boolean is1xxInformational() &#123; return Series.INFORMATIONAL.equals(series()); &#125; /** * Whether this status code is in the HTTP series * &#123;@link org.springframework.http.HttpStatus.Series#SUCCESSFUL&#125;. * This is a shortcut for checking the value of &#123;@link #series()&#125;. */ public boolean is2xxSuccessful() &#123; return Series.SUCCESSFUL.equals(series()); &#125; /** * Whether this status code is in the HTTP series * &#123;@link org.springframework.http.HttpStatus.Series#REDIRECTION&#125;. * This is a shortcut for checking the value of &#123;@link #series()&#125;. */ public boolean is3xxRedirection() &#123; return Series.REDIRECTION.equals(series()); &#125; /** * Whether this status code is in the HTTP series * &#123;@link org.springframework.http.HttpStatus.Series#CLIENT_ERROR&#125;. * This is a shortcut for checking the value of &#123;@link #series()&#125;. */ public boolean is4xxClientError() &#123; return Series.CLIENT_ERROR.equals(series()); &#125; /** * Whether this status code is in the HTTP series * &#123;@link org.springframework.http.HttpStatus.Series#SERVER_ERROR&#125;. * This is a shortcut for checking the value of &#123;@link #series()&#125;. */ public boolean is5xxServerError() &#123; return Series.SERVER_ERROR.equals(series()); &#125; /** * Returns the HTTP status series of this status code. * @see HttpStatus.Series */ public Series series() &#123; return Series.valueOf(this); &#125; /** * Return a string representation of this status code. */ @Override public String toString() &#123; return Integer.toString(this.value); &#125; /** * Return the enum constant of this type with the specified numeric value. * @param statusCode the numeric value of the enum to be returned * @return the enum constant with the specified numeric value * @throws IllegalArgumentException if this enum has no constant for the specified numeric value */ public static HttpStatus valueOf(int statusCode) &#123; for (HttpStatus status : values()) &#123; if (status.value == statusCode) &#123; return status; &#125; &#125; throw new IllegalArgumentException(&quot;No matching constant for [&quot; + statusCode + &quot;]&quot;); &#125; /** * Enumeration of HTTP status series. * &lt;p&gt;Retrievable via &#123;@link HttpStatus#series()&#125;. */ public enum Series &#123; INFORMATIONAL(1), SUCCESSFUL(2), REDIRECTION(3), CLIENT_ERROR(4), SERVER_ERROR(5); private final int value; Series(int value) &#123; this.value = value; &#125; /** * Return the integer value of this status series. Ranges from 1 to 5. */ public int value() &#123; return this.value; &#125; public static Series valueOf(int status) &#123; int seriesCode = status / 100; for (Series series : values()) &#123; if (series.value == seriesCode) &#123; return series; &#125; &#125; throw new IllegalArgumentException(&quot;No matching constant for [&quot; + status + &quot;]&quot;); &#125; public static Series valueOf(HttpStatus status) &#123; return valueOf(status.value); &#125; &#125;&#125; 6. 测试示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@ResponseBody@RequestMapping(&quot;/json&quot;)public Resp json(String token) &#123; MemberDetails member = memberService.getMemberDetailsByToken(token); return Resp.success(member, 5L, 1, 3); //这里分页信息，请自己从PageHelper返回的数据中得到。参看下面注释内容： //Page&lt;Object&gt; page = PageHelper.startPage(1, 5); //MemberDetails member = memberService.getMemberDetailsByToken(token); //return Resp.success(member, page.getTotal(), page.getPageNum(), page.getPageSize());&#125;@ResponseBody@RequestMapping(&quot;/json2&quot;)public Resp json2(String token) &#123; MemberDetails member = memberService.getMemberDetailsByToken(token); Map&lt;String, Object&gt; ext = new HashMap&lt;&gt;(); ext.put(&quot;msg&quot;, &quot;扩展内容&quot;); return Resp.success(&quot;成功了&quot;, member, ext, 5L, 1, 3);&#125;@ResponseBody@RequestMapping(&quot;/json3&quot;)public Resp json3(String token) &#123; MemberDetails member = memberService.getMemberDetailsByToken(token); return Resp.fail();&#125;@ResponseBody@RequestMapping(&quot;/json4&quot;)public Resp json4(String token) &#123; MemberDetails member = memberService.getMemberDetailsByToken(token); Map&lt;String, Object&gt; ext = new HashMap&lt;&gt;(); ext.put(&quot;msg&quot;, &quot;扩展内容&quot;); return Resp.result(&quot;201&quot;, &quot;成功了&quot;, member);&#125;@ResponseBody@RequestMapping(&quot;/json5&quot;)public Resp json5(String token) &#123; MemberDetails member = memberService.getMemberDetailsByToken(token); return Resp.success(member);&#125;@ResponseBody@RequestMapping(&quot;/json6&quot;)public Resp json6(String token) &#123; MemberDetails member = memberService.getMemberDetailsByToken(token); return Resp.httpStatus(HttpStatus.ACCEPTED, &quot;成功了&quot;);&#125; 7. 运行结果： 访问：http://127.0.0.1:1230/json?token=123 访问：http://127.0.0.1:1230/json2?token=123 访问：http://127.0.0.1:1230/json3?token=123 访问：http://127.0.0.1:1230/json4?token=123 访问：http://127.0.0.1:1230/json5?token=123 访问：http://127.0.0.1:1230/json6?token=123 更多用法，请查看Resp类里面的静态方法 后记： 如果大家有更好的改进建议或代码，欢迎在评论留言反馈，谢谢！","categories":[{"name":"Restful","slug":"Restful","permalink":"http://www.seifon.cn/categories/Restful/"}],"tags":[{"name":"Rest","slug":"Rest","permalink":"http://www.seifon.cn/tags/Rest/"},{"name":"Json","slug":"Json","permalink":"http://www.seifon.cn/tags/Json/"},{"name":"Util","slug":"Util","permalink":"http://www.seifon.cn/tags/Util/"}]},{"title":"利用Filter和Spring拦截器，将用户信息动态传入Request方法","slug":"利用Filter和拦截器，将用户信息动态传入Request方法","date":"2018-04-21T12:14:00.000Z","updated":"2018-06-05T14:41:24.000Z","comments":true,"path":"2018/04/21/利用Filter和拦截器，将用户信息动态传入Request方法/","link":"","permalink":"http://www.seifon.cn/2018/04/21/利用Filter和拦截器，将用户信息动态传入Request方法/","excerpt":"","text":"前言： 在开发当中，经常会验证用户登录状态和获取用户信息。如果每次都手动调用用户信息查询接口，会非常的繁琐，而且代码冗余。为了提高开发效率，因此就有了今天这篇文章。 思路： 用户请求我们的方法会携带一个Token，通过Filter过滤器将会员信息查出来并放到request请求参数中。接着在Cotroller层的请求方法中接收一个MemberDeatails类型的参数，就能直接获得会员信息了。 详细步骤：1. Gradle引入需要的Jar包：1compile &quot;com.fasterxml.jackson.core:jackson-databind:2.8.10&quot; 2. 定义一个Login注解12345678@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Login &#123; String value() default &quot;&quot;;&#125; 3. 定义一个MemberDetails.class，用于封装用户信息12345678910111213public class MemberDetails &#123; private String memberId; private String memberName; private String memberNickname; private String memberPhone; private String memberEmail;&#125; 5. 定义一个会员接口类12345678910/** * @Author: XiongFeng * @Description: 会员接口 * @Date: Created in 19:40 2018/4/10 */public interface MemberService &#123; /** 根据TokenId获取用户信息 */ MemberDto getMemberByToken(String token);&#125; 6. 定义一个会员接口实现类，在里面写上用户信息获取方法12345678910111213141516@Servicepublic class MemberServiceImpl implements MemberService &#123; @Override public MemberDetails getMemberDetailsByToken(String token) &#123; if (StringUtils.isBlank(token)) return null; if (!&quot;123&quot;.equals(token)) return null; MemberDetails memberDetails = new MemberDetails(); memberDetails.setMemberId(&quot;123&quot;); memberDetails.setMemberName(&quot;哈哈123&quot;); memberDetails.setMemberEmail(&quot;seifon@seifon.cn&quot;); memberDetails.setMemberNickname(&quot;Seifon&quot;); memberDetails.setMemberPhone(&quot;13100001111&quot;); return memberDetails; &#125;&#125; 7. 定义一个Request请求包装类 通过继承HttpServletRequestWrapper类，重写它里面的多个方法，对前端传过来的参数进行重新封装。因为在Filter，虽然可以通过request.getParameterMap()拿到一个含有参数的map，但是不能直接对request里面东西进行修改操作，一旦重新修改，就会报错。后来我发现j2ee已经给我们提供了解决的办法，使用HttpServletRequestWrapper类来解决向request添加额外参数的功能。于是我对HttpServletRequest进行重新包装，在里面重新定义一个map，将以前的参数put进去，并将我们需要添加的参数放进去，达到我们想要的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;import java.util.Vector;/** * @Author: XiongFeng * @Description: 对Request请求重新包装 * @Date: Created in 11:17 2018/4/13 */public class ParameterRequestWrapper extends HttpServletRequestWrapper &#123; private Map&lt;String , String[]&gt; params = new HashMap&lt;String, String[]&gt;(); @SuppressWarnings(&quot;unchecked&quot;) public ParameterRequestWrapper(HttpServletRequest request) &#123; // 将request交给父类，以便于调用对应方法的时候，将其输出，其实父亲类的实现方式和第一种new的方式类似 super(request); //将参数表，赋予给当前的Map以便于持有request中的参数 this.params.putAll(request.getParameterMap()); &#125; //重载一个构造方法 public ParameterRequestWrapper(HttpServletRequest request , Map&lt;String , Object&gt; extendParams) &#123; this(request); addAllParameters(extendParams);//这里将扩展参数写入参数表 &#125; /** * 复写获取key的方法 */ @Override public Enumeration getParameterNames() &#123; Vector names = new Vector(params.keySet()); return names.elements(); &#125; /** * 复写获取值value的方法 */ @Override public String getParameter(String name) &#123; Object v = params.get(name); if (v == null) &#123; return null; &#125; else if (v instanceof String[]) &#123; String[] strArr = (String[]) v; if (strArr.length &gt; 0) &#123; return strArr[0]; &#125; else &#123; return null; &#125; &#125; else if (v instanceof String) &#123; return (String) v; &#125; else &#123; return v.toString(); &#125; &#125; @Override public String[] getParameterValues(String name) &#123; Object v = params.get(name); if (v == null) &#123; return null; &#125; else if (v instanceof String[]) &#123; return (String[]) v; &#125; else if (v instanceof String) &#123; return new String[] &#123; (String) v &#125;; &#125; else &#123; return new String[] &#123; v.toString() &#125;; &#125; &#125; public void addAllParameters(Map&lt;String , Object&gt;otherParams) &#123;//增加多个参数 for(Map.Entry&lt;String , Object&gt;entry : otherParams.entrySet()) &#123; addParameter(entry.getKey() , entry.getValue()); &#125; &#125; public void addParameter(String name , Object value) &#123;//增加参数 if(value != null) &#123; if(value instanceof String[]) &#123; params.put(name , (String[])value); &#125;else if(value instanceof String) &#123; params.put(name , new String[] &#123;(String)value&#125;); &#125;else &#123; params.put(name , new String[] &#123;String.valueOf(value)&#125;); &#125; &#125; &#125; /** 简单封装，请根据需求改进 */ public void addObject(Object obj) &#123; Class&lt;?&gt; clazz = obj.getClass(); Method[] methods = clazz.getMethods(); try &#123; for (Method method : methods) &#123; if (!method.getName().startsWith(&quot;get&quot;)) &#123; continue; &#125; Object invoke = method.invoke(obj); if (invoke == null || &quot;&quot;.equals(invoke)) &#123; continue; &#125; String filedName = method.getName().replace(&quot;get&quot;, &quot;&quot;); filedName = WordUtils.uncapitalize(filedName); if (invoke instanceof Collection) &#123; Collection collections = (Collection) invoke; if (collections != null &amp;&amp; collections.size() &gt; 0) &#123; String[] strings = (String[]) collections.toArray(); addParameter(filedName, strings); return; &#125; &#125; addParameter(filedName, invoke); &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 8. 定义一个过滤器 在这个过滤里面，主要校验Token是否有效以及将会员信息添加到request。首先，从Request请求头中拿到前端传过来的Token，并使用Token调用会员信息获取接口，得到用户的资料，然后将用户信息put到ParameterMap中，这个ParameterMap是我们通过ParameterRequestWrapper重新包装的一个map，因此可以在里面添加会员的参数，然后将新的request传递出去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.util.Date;import java.util.HashMap;import java.util.Map;/** * @Author: XiongFeng * @Description: 会员登录信息过滤器 * @Date: Created in 11:17 2018/4/13 */@Component@WebFilter(urlPatterns = &quot;/*&quot;)public class MemberFilter implements Filter &#123; MemberService memberService = new MemberServiceImpl(); ObjectMapper objectMapper = new ObjectMapper(); @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; String tokenId = req.getHeader(&quot;X-Authorization&quot;); if (tokenId == null || &quot;&quot;.equals(tokenId) || tokenId.isEmpty()) &#123; chain.doFilter(request, response); return; &#125; MemberDetails memberDetails = memberService.getMemberDetailsByToken(tokenId); if (memberDetails == null) this.respFail(response); ParameterRequestWrapper requestWrapper = new ParameterRequestWrapper(req); requestWrapper.addObject(memberDetails); chain.doFilter(requestWrapper, response); &#125; /** 返回失败结果Json数据 */ private void respFail(ServletResponse response) throws IOException &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;status&quot;, 500); map.put(&quot;message&quot;, &quot;登录失效，请登录&quot;); map.put(&quot;data&quot;, null); String s = objectMapper.writeValueAsString(map); response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json; charset=utf-8&quot;); response.getWriter().write(s); &#125; @Override public void destroy() &#123; &#125;&#125; 9. 定义一个SpringMVC拦截器 在这个拦截器里面，主要验证Controller方法中是否需要MemberDetails和是否标了@Login注解。首先，从HandlerMethod中获取所有入参，看有没有需要MemberDetails参数，如果有，就从HttpServletRequest中拿memberId，如果不存在说明没有登录，存在就通过。然后HandlerMethod获取@Login注解，判断是否存在，如果存在，就看有没有memberId,没有就不通过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.seifon.paymodle.interceptor;import cn.seifon.paymodle.annotations.Login;import cn.seifon.paymodle.dto.MemberDetails;import cn.seifon.paymodle.service.manager.member.MemberService;import cn.seifon.paymodle.service.manager.member.impl.MemberServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.core.MethodParameter;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Type;import java.util.HashMap;import java.util.Map;/** * @Author: XiongFeng * @Description: 会员登录信息拦截器 * @Date: Created in 11:17 2018/4/13 */public class MemberInterceptor extends HandlerInterceptorAdapter &#123; ObjectMapper objectMapper = new ObjectMapper(); MemberService memberService = new MemberServiceImpl(); public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123; HandlerMethod method = (HandlerMethod) handler; String[] memberIds = request.getParameterValues(&quot;memberId&quot;); MethodParameter[] methodParameters = method.getMethodParameters(); //判断方法类是否有MemberDetails入参 if (methodParameters.length &gt; 0) &#123; for (MethodParameter methodParameter : methodParameters) &#123; Type genericParameterType = methodParameter.getGenericParameterType(); String typeName = genericParameterType.getTypeName(); if (!typeName.equals(MemberDetails.class.getTypeName())) continue; if (memberIds == null || memberIds.length &lt;= 0) return this.respFail(response); //如果找不到用户信息就返回失败 break; &#125; &#125; //判断是否有Login注解 Login login = method.getMethodAnnotation(Login.class); if (login == null) return true; if (memberIds == null || memberIds.length &lt;= 0) return this.respFail(response); //如果找不到用户信息就返回失败 return true; &#125; /** 返回失败结果Json数据 */ private boolean respFail(HttpServletResponse response) throws IOException &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;status&quot;, 500); map.put(&quot;message&quot;, &quot;登录失效，请登录&quot;); map.put(&quot;data&quot;, null); String s = objectMapper.writeValueAsString(map); response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json; charset=utf-8&quot;); response.getWriter().write(s); return false; &#125;&#125; 10. 将拦截器注册到WebMvcConfigurer中123456789101112@Configurationpublic class MyWebAppConfigurer extends WebMvcConfigurerAdapter &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; // addPathPatterns 用于添加拦截规则 registry.addInterceptor(new MemberInterceptor()).addPathPatterns(&quot;/**&quot;); super.addInterceptors(registry); &#125;&#125; 11. 定义会员Controller 经过一个过滤器和一个拦截器，request请求终于来到了我们Controller层。这时候，我们只需要在方法里面写入MemberDetails memberDetails 就OK了，不用做任何操作，我们就可以获取会员信息了，是不是炒鸡方便！另外还可以在方法上标@Login注解。 12345678910111213141516@RestControllerpublic class MemberController &#123; @RequestMapping(&quot;/token&quot;) @Login public Map&lt;String, Object&gt; getUser(MemberDetails memberDetails) &#123; //User user = userManager.selectByPrimaryKey(id); Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;status&quot;, 200); map.put(&quot;message&quot;, &quot;请求成功&quot;); map.put(&quot;data&quot;, memberDetails); return map; &#125;&#125; 运行结果： 遇到的坑： 当时我尝试过把会员参数放到session域中的Attribute，也尝试过在Model里setAttribute。后来发现这是行不通的，在filter中直接使用request.setAttribute()是无效的。放在Modle也是可行，但是Controller里面的方法需要加@ModelAttribute(“…”)才能得到用户信息，很不方便。唯有通过request.getParameterMap() put()进去，才是最方便的。 一开始我没想到用过滤器，因此我就尝试在拦截器里，直接通过ParameterRequestWrapper对request包装，后来发现不管我怎么弄都不成功。当时非常绝望，后来想了想会不会是拦截器不支持重新包装request，于是我就通过filter去做，没想到成功了。这时，我想既然用到了filter，那干脆直接在filter里面获取@Login注解和获取方法参数得了，后来发现filter里面拿不到方法的信息，哭。后来想到一个办法，可以通过先filter，后拦截器。于是就成功了！ 后记： 这篇文章只是记录了我的一点小小经验，如果有什么不对的地方或者有更好的方法，请大家在评论里留言指正！ 参考文章：http://www.importnew.com/19023.html","categories":[{"name":"Spring","slug":"Spring","permalink":"http://www.seifon.cn/categories/Spring/"}],"tags":[{"name":"拦截器","slug":"拦截器","permalink":"http://www.seifon.cn/tags/拦截器/"},{"name":"Filter","slug":"Filter","permalink":"http://www.seifon.cn/tags/Filter/"}]},{"title":"Nginx的五种负载算法模式","slug":"Nginx的五种负载算法模式","date":"2017-09-04T17:03:00.000Z","updated":"2018-01-24T15:13:45.000Z","comments":true,"path":"2017/09/05/Nginx的五种负载算法模式/","link":"","permalink":"http://www.seifon.cn/2017/09/05/Nginx的五种负载算法模式/","excerpt":"","text":"1、轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 例如： 1234upstream bakend &#123; server 192.168.0.14; server 192.168.0.15; &#125; 2、weight权重指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如： 1234upstream bakend &#123; server 192.168.0.14 weight=10; server 192.168.0.15 weight=10; &#125; 3、ip_hash每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如： 12345upstream bakend &#123; ip_hash; server 192.168.0.14:88; server 192.168.0.15:80; &#125; 4、fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream backend &#123; server server1; server server2; fair; &#125; 5、url_hash（第三方）按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 123456upstream backend &#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32; &#125; tips: 1234567upstream bakend&#123;#定义负载均衡设备的Ip及设备状态 ip_hash; server 127.0.0.1:9090 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6060; server 127.0.0.1:7070 backup; &#125; 在需要使用负载均衡的server中增加 1proxy_pass http://bakend/; 每个设备的状态设置为: 1.down 表示单前的server暂时不参与负载 2.weight 默认为1.weight越大，负载的权重就越大。 3.max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 4.fail_timeout:max_fails次失败后，暂停的时间。 5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.seifon.cn/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.seifon.cn/tags/Nginx/"},{"name":"负载均衡","slug":"负载均衡","permalink":"http://www.seifon.cn/tags/负载均衡/"}]},{"title":"高CPU占用调优","slug":"高CPU占用调优","date":"2017-09-04T16:39:00.000Z","updated":"2018-01-24T15:13:45.000Z","comments":true,"path":"2017/09/05/高CPU占用调优/","link":"","permalink":"http://www.seifon.cn/2017/09/05/高CPU占用调优/","excerpt":"","text":"根据top命令，发现PID为28555的Java进程占用CPU高达200%，出现故障。 通过查看进程1ps aux | grep PID 可以进一步确定是tomcat进程出现了问题。 但是，怎么定位到具体线程或者代码呢？ 首先显示线程列表:1ps -mp pid -o THREAD,tid,time 找到了耗时最高的线程28802，占用CPU时间快两个小时了！ 其次将需要的线程ID转换为16进制格式：1printf &quot;%x\\n&quot; tid 最后打印线程的堆栈信息：1jstack pid |grep tid(16进制线程ID) –A60 找到有问题的java代码(省略)，进行业务调整和编码修改 最后，总结下排查CPU故障的方法和技巧有哪些： 1、top命令：Linux命令。可以查看实时的CPU使用情况。也可以查看最近一段时间的CPU使用情况。 2、PS命令：Linux命令。强大的进程状态监控命令。可以查看进程以及进程中线程的当前CPU使用情况。属于当前状态的采样数据。 3、jstack：Java提供的命令。可以查看某个进程的当前线程栈运行情况。根据这个命令的输出可以定位某个进程的所有线程的当前运行状态、运行代码，以及是否死锁等等。","categories":[{"name":"JAVA调优","slug":"JAVA调优","permalink":"http://www.seifon.cn/categories/JAVA调优/"}],"tags":[{"name":"调优","slug":"调优","permalink":"http://www.seifon.cn/tags/调优/"},{"name":"Jstack","slug":"Jstack","permalink":"http://www.seifon.cn/tags/Jstack/"},{"name":"栈","slug":"栈","permalink":"http://www.seifon.cn/tags/栈/"}]},{"title":"开关指定端口，以80为例","slug":"开关指定端口，以80为例","date":"2017-07-09T06:02:54.000Z","updated":"2018-01-24T15:13:45.000Z","comments":true,"path":"2017/07/09/开关指定端口，以80为例/","link":"","permalink":"http://www.seifon.cn/2017/07/09/开关指定端口，以80为例/","excerpt":"开启80端口：1iptables -I INPUT -p tcp --dport 80 -j ACCEPT","text":"开启80端口：1iptables -I INPUT -p tcp --dport 80 -j ACCEPT 关闭80端口：1iptables -I INPUT -p tcp --dport 80 -j DROP 保存并重启Iptables：12/etc/init.d/iptables saveservice iptables restart","categories":[{"name":"Iptables","slug":"Iptables","permalink":"http://www.seifon.cn/categories/Iptables/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://www.seifon.cn/tags/centos/"},{"name":"linux","slug":"linux","permalink":"http://www.seifon.cn/tags/linux/"},{"name":"iptables","slug":"iptables","permalink":"http://www.seifon.cn/tags/iptables/"},{"name":"防火墙","slug":"防火墙","permalink":"http://www.seifon.cn/tags/防火墙/"}]},{"title":"Jenkins环境搭建","slug":"Jenkins环境搭建","date":"2017-07-07T17:52:00.000Z","updated":"2018-01-24T15:13:45.000Z","comments":true,"path":"2017/07/08/Jenkins环境搭建/","link":"","permalink":"http://www.seifon.cn/2017/07/08/Jenkins环境搭建/","excerpt":"","text":"上传以下的包到/tmp/目录下：1234567891011jdk-8u121-linux-x64.tar.gzapache-tomcat-7.0.75.tar.gzapache-maven-3.5.0-bin.tar.gzMySQL-client-5.5.52-1.el6.x86_64.rpmMySQL-devel-5.5.52-1.el6.x86_64.rpmMySQL-server-5.5.52-1.el6.x86_64.rpmMySQL-shared-5.5.52-1.el6.x86_64.rpmgit-2.9.3.tar.gzjenkins.war 解压包到/opt/目录下：12345tar -xvzf /tmp/jdk-8u121-linux-x64.tar.gz -C /opt/tar -xvzf /tmp/apache-tomcat-7.0.75.tar.gz -C /opt/tar -xvzf /tmp/apache-maven-3.5.0-bin.tar.gz -C /opt/ 配置环境变量：12345678910111213vim /etc/profileJAVA_HOME=/opt/jdk1.8.0_121CATALINA_HOME=/opt/apache-tomcat-7.0.75MAVEN_HOME=/opt/apache-maven-3.5.0PATH=/opt/jdk1.8.0_121/bin:/opt/apache-tomcat-7.0.75/bin:/opt/apache-maven-3.5.0/bin:$PATHCLASSPATH=.:/opt/jdk1.8.0_121/lib/dt.jar:/opt/jdk1.8.0_121/lib/tools.jarexport JAVA_HOME PATH CLASSPATH CATALINA_HOME MAVEN_HOMEsource /etc/profile 配置Tomcat自启动： (1)、在/etc/init.d目录下创建文件：tomcat 内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/bin/bash# This is the init script for starting up the# Jakarta Tomcat server## chkconfig: 345 91 10# description: Starts and stops the Tomcat daemon.## Source function library.. /etc/rc.d/init.d/functions# Get config.. /etc/sysconfig/network# Check that networking is up.[ &quot;$&#123;NETWORKING&#125;&quot; = &quot;no&quot; ] &amp;&amp; exit 0export JAVA_HOME=/opt/jdk1.8.0_121export CATALINA_HOME=/opt/apache-tomcat-7.0.75startup=$CATALINA_HOME/bin/startup.shshutdown=$CATALINA_HOME/bin/shutdown.shstart()&#123; echo -n &quot;Starting Tomcat service:&quot; cd $tomcat_home $startup echo &quot;tomcat is succeessfully started up&quot;&#125;stop()&#123; echo -n &quot;Shutting down tomcat: &quot; cd $tomcat_home $shutdown echo &quot;tomcat is succeessfully shut down.&quot;&#125;status()&#123; numproc=`ps -ef | grep catalina | grep -v &quot;grep catalina&quot; | wc -l` if [ $numproc -gt 0 ]; then echo &quot;Tomcat is running...&quot; else echo &quot;Tomcat is stopped...&quot; fi&#125;restart()&#123; stop start&#125;# See how we were called.case &quot;$1&quot; instart) start ;;stop) stop ;;status) status ;;restart) restart ;;*) echo $&quot;Usage: $0 &#123;start|stop|status|restart&#125;&quot; exit 1esac (2)、配置权限，并加入自启： 1234cd /etc/init.dchmod 755 ./tomcatchkconfig --add tomcatchkconfig tomcat on (3)、设置URIEncoding=”UTF-8” 1vim /opt/apache-tomcat-7.0.75/conf/server.xml (4)、给Tomcat设置用户名密码 1234567vim /opt/apache-tomcat-7.0.75/conf/tomcat-users.xml&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;role rolename=&quot;manager-jmx&quot;/&gt;&lt;role rolename=&quot;manager-status&quot;/&gt;&lt;user username=&quot;tomcat_user&quot; password=&quot;123456&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status&quot; /&gt; (5)、打开/etc/sysconfig/iptables 加入以下代码： 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT (6)、重启防火墙服务 1service iptables restart 安装Mysql服务： 安装服务器端 1234rpm -ivh /tmp/MySQL-server-5.5.52-1.el6.x86_64.rpm如果出现报错就执行：rpm -e --nodeps mysql-libs-5.1.73-7.el6.x86_64 安装客户端 1rpm -ivh /tmp/MySQL-client-5.5.52-1.el6.x86_64.rpm 启动MySQL服务 1service mysql start 修改MySQL服务器登录密码 1/usr/bin/mysqladmin -u root password &apos;root&apos; 修改防火墙端口： 12345vim /etc/sysconfig/iptables-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPTservice iptables restart 修改MySQL服务器访问权限 第一步：登录MySQL服务器 第二步：use mysql; 第三步：查看user表部分内容 123456789101112mysql&gt; select host,user,password from user; +--------------+------+-------------------------------------------+ | host | user | password | +--------------+------+-------------------------------------------+ | localhost | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | computer0325 | root | | | 127.0.0.1 | root | | | ::1 | root | | | localhost | | | | computer0325 | | | +--------------+------+-------------------------------------------+ 6 rows in set (0.00 sec) 第四步：插入特定数据 1insert into user(host,user,password) values(&apos;%&apos;,&apos;root&apos;,&apos;*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B&apos;); 第五步：再次查看user表内容 123456789101112mysql&gt; select host,user,password from user; +--------------+------+-------------------------------------------+ | host | user | password | +--------------+------+-------------------------------------------+ | localhost | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | computer0325 | root | | | 127.0.0.1 | root | | | ::1 | root | | | localhost | | | | computer0325 | | | | % | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | +--------------+------+-------------------------------------------+ 第六步：为root@%授权 1mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION; 第七步：退出MySQL 1mysql&gt; exit; 第八步：重启MySQL服务 1service mysql restart; 编译安装git 安装依赖： 123yum install curl-devel expat-devel gettext-devel openssl-devel zlib-develyum install gcc perl-ExtUtils-MakeMaker 删除已有的git： 1yum remove git 编译git： 123456tar -xvzf ./git-2.9.3.tar.gz -C /opt/cd /opt/git-2.9.3/make prefix=/usr/local/git allmake prefix=/usr/local/git installecho &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrcsource /etc/bashrc 检查版本： 1git --version 部署Jenkins.war包，以及初始化环境：1cp /tmp/jenkins.war /opt/apache-tomcat-7.0.75/webapps/ 通过浏览器访问Tomcat下的jenkins应用 1例如：http://[server-address]:8080/jenkins/ 输入内置密钥串 先不安装插件，后面有需要时再安装，点右上角的× 修改默认管理员密码 安装GitHub plugin 和 Deploy to container Plugin 插件 点击系统管理，进入系统设置界面 Configure Global Security 123①勾选允许用户注册，这样万一我们忘记了之前的账号密码还可以再注册一个②勾选任何用户可以做任何事(没有任何限制)③取消防止跨站点请求伪造勾选 Global Tool Configuration ①设置Maven ②设置JDK，不要选自动安装，因为我们自己安装过了 ③设置MAVEN_HOME，同样不要自动安装 ④设置Git：/usr/local/git/bin/git","categories":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://www.seifon.cn/categories/Jenkins/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://www.seifon.cn/tags/Jenkins/"},{"name":"CI","slug":"CI","permalink":"http://www.seifon.cn/tags/CI/"}]},{"title":"Yaml语法说明","slug":"Yaml语法说明","date":"2017-06-26T17:19:00.000Z","updated":"2018-01-24T15:13:45.000Z","comments":true,"path":"2017/06/27/Yaml语法说明/","link":"","permalink":"http://www.seifon.cn/2017/06/27/Yaml语法说明/","excerpt":"","text":"简介YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。 语法规则 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 ：冒号后面必须有空格 #表示注释，从这个字符一直到行尾，都会被解析器忽略。 YAML支持三种数据结构： 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 对象 一、对象的一组键值对，使用冒号结构表示。 1animal: pets 转为 JavaScript 如下： 1&#123; animal: &apos;pets&apos; &#125; 二、将所有键值对写成一个行内对象。 1hash: &#123; name: Steve, foo: bar &#125; 转为 JavaScript 如下 1&#123; hash: &#123; name: &apos;Steve&apos;, foo: &apos;bar&apos; &#125; &#125; 数组 一、一组连词线开头的行，构成一个数组。 123- Cat- Dog- Goldfish 转为 JavaScript 如下。 1[ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ] 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。 1234- - Cat - Dog - Goldfish 转为 JavaScript 如下。 1[ [ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ] ] 二、数组也可以采用行内表示法。 1animal: [Cat, Dog] 转为 JavaScript 如下。 1&#123; animal: [ &apos;Cat&apos;, &apos;Dog&apos; ] &#125; 复合结构 对象和数组可以结合使用，形成复合结构。 123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 转为 JavaScript 如下： 123456&#123; languages: [ &apos;Ruby&apos;, &apos;Perl&apos;, &apos;Python&apos; ], websites: &#123; YAML: &apos;yaml.org&apos;, Ruby: &apos;ruby-lang.org&apos;, Python: &apos;python.org&apos;, Perl: &apos;use.perl.org&apos; &#125; &#125; 纯量 纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 字符串布尔值整数浮点数Null时间日期 数值直接以字面量的形式表示。 1number: 12.30 转为 JavaScript 如下。 1&#123; number: 12.30 &#125; 布尔值用true和false表示。 1isSet: true 转为 JavaScript 如下。 1&#123; isSet: true &#125; null用~表示。 1parent: ~ 转为 JavaScript 如下。 1&#123; parent: null &#125; 时间采用 ISO8601 格式。 1iso8601: 2001-12-14t21:59:43.10-05:00 转为 JavaScript 如下。 1&#123; iso8601: new Date(&apos;2001-12-14t21:59:43.10-05:00&apos;) &#125; 日期采用复合 iso8601 格式的年、月、日表示。 1date: 1976-07-31 转为 JavaScript 如下。 1&#123; date: new Date(&apos;1976-07-31&apos;) &#125; YAML 允许使用两个感叹号，强制转换数据类型。 12e: !!str 123f: !!str true 转为 JavaScript 如下。 1&#123; e: &apos;123&apos;, f: &apos;true&apos; &#125; 字符串 字符串是最常见，也是最复杂的一种数据类型。字符串默认不使用引号表示。 1str: 这是一行字符串 转为 JavaScript 如下。 1&#123; str: &apos;这是一行字符串&apos; &#125; 如果字符串之中包含空格或特殊字符，需要放在引号之中。 1str: &apos;内容： 字符串&apos; 转为 JavaScript 如下。 1str: &apos;内容: 字符串&apos; 单引号和双引号都可以使用，双引号不会对特殊字符转义。 12s1: &apos;内容\\n字符串&apos;s2: &quot;内容\\n字符串&quot; 转为 JavaScript 如下。 1&#123; s1: &apos;内容\\\\n字符串&apos;, s2: &apos;内容\\n字符串&apos; &#125; 单引号之中如果还有单引号，必须连续使用两个单引号转义。 1str: &apos;labor&apos;&apos;s day&apos; 转为 JavaScript 如下。 1&#123; str: &apos;labor\\&apos;s day&apos; &#125; 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。 123str: 这是一段 多行 字符串 转为 JavaScript 如下。 1&#123; str: &apos;这是一段 多行 字符串&apos; &#125; 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。 123456this: | Foo Barthat: &gt; Foo Bar 转为 JavaScript 代码如下。 1&#123; this: &apos;Foo\\nBar\\n&apos;, that: &apos;Foo Bar\\n&apos; &#125; +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。 123456789s1: | Foos2: |+ Foos3: |- Foo 转为 JavaScript 代码如下。 1&#123; s1: &apos;Foo\\n&apos;, s2: &apos;Foo\\n\\n\\n&apos;, s3: &apos;Foo&apos; &#125; 字符串之中可以插入 HTML 标记。 1234message: | 段落 转为 JavaScript 如下。 123&#123; message: &apos;\\n\\n 段落\\n\\n&apos; &#125; 引用 锚点&amp;和别名*，可以用来引用。 1234567891011defaults: &amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &lt;&lt;: *defaultstest: database: myapp_test &lt;&lt;: *defaults 等同于下面的代码。 12345678910111213defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。 下面是另一个例子。 12345- &amp;showell Steve - Clark - Brian - Oren - *showell 转为 JavaScript 代码如下。 1[ &apos;Steve&apos;, &apos;Clark&apos;, &apos;Brian&apos;, &apos;Oren&apos;, &apos;Steve&apos; ] 函数和正则表达式的转换 这是 JS-YAML 库特有的功能，可以把函数和正则表达式转为字符串。 123# example.ymlfn: function () &#123; return 1 &#125;reg: /test/ 解析上面的 yml 文件的代码如下。 1234567891011var yaml = require(&apos;js-yaml&apos;);var fs = require(&apos;fs&apos;);try &#123; var doc = yaml.load( fs.readFileSync(&apos;./example.yml&apos;, &apos;utf8&apos;) ); console.log(doc);&#125; catch (e) &#123; console.log(e);&#125; 从 JavaScript 对象还原到 yaml 文件的代码如下。 1234567891011121314151617var yaml = require(&apos;js-yaml&apos;);var fs = require(&apos;fs&apos;);var obj = &#123; fn: function () &#123; return 1 &#125;, reg: /test/&#125;;try &#123; fs.writeFileSync( &apos;./example.yml&apos;, yaml.dump(obj), &apos;utf8&apos; );&#125; catch (e) &#123; console.log(e);&#125;","categories":[{"name":"Yaml","slug":"Yaml","permalink":"http://www.seifon.cn/categories/Yaml/"}],"tags":[{"name":"Yaml","slug":"Yaml","permalink":"http://www.seifon.cn/tags/Yaml/"},{"name":"yml","slug":"yml","permalink":"http://www.seifon.cn/tags/yml/"}]},{"title":"Mysql异地定时备份方法","slug":"Mysql异地定时备份方法","date":"2017-05-02T16:51:00.000Z","updated":"2018-01-24T15:13:45.000Z","comments":true,"path":"2017/05/03/Mysql异地定时备份方法/","link":"","permalink":"http://www.seifon.cn/2017/05/03/Mysql异地定时备份方法/","excerpt":"","text":"两台linux服务器： 一台199.20.30.222（mysql服务器） 一台199.20.30.226（与mysql互通的一台server） 思路：mysql本地做一份备份；226Server做一份同步备份，脚本放在222上面，定时任务也设置在222上面。 （1）mysql本地备份：1234#!/bin/sh#mysql_backupDATE=`date +%Y%m%d`/opt/mysql/bin/mysqldump --opt jsweb -u root &gt; /opt/mysqlbackup/$DATE.sql （2）将本地备份同步到远端226上面：12345#!/bin/bash#date:2013/09/24#function:The script is used copying mysqlbackup to 226DATE=`date +%Y%m%d`scp /opt/mysqlbackup/$DATE.sql root@199.20.30.226:/data/2013backup/mysql/ （3）222上面设置定时任务：123vim/etc/crontable OR crontable -e30 1 * * * /bin/sh /home/jiaoben/backup.sh ===============每天1：30执行30 3 * * * /bin/sh /home/jiaoben/scp.sh ===============每天3：30执行 注意：两个linux之间相互拷贝文件，使用scp工具必须输入远端密码,所以在进行（2）时，需要规避输入密码，否则自动备份到remote不会生效, 本人采用的方法：使两个服务器互相信任，执行scp时，就可以免输入密码。 12345ssh-keygen -t rsacd /root/.ssh/scp id_rsa.pub root@199.20.30.226:/root/ssh/ssh root@199.20.30.226mv /root/.ssh/id_isa_pub /root/.ssh/authorized_key 时间过长备份的mysql就需要定时清理12find /opt/mysqlbackup/ -type f -name \\*.sql -mtime +10 -exec rm -fr &#123;&#125; \\;find /opt/mysqlbackup/ -type f -name &quot;*.sql&quot; -mtime +10 -exec rm -fr &#123;&#125; \\;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.seifon.cn/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.seifon.cn/tags/Mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://www.seifon.cn/tags/数据库/"},{"name":"备份","slug":"备份","permalink":"http://www.seifon.cn/tags/备份/"},{"name":"定时","slug":"定时","permalink":"http://www.seifon.cn/tags/定时/"},{"name":"容灾","slug":"容灾","permalink":"http://www.seifon.cn/tags/容灾/"}]},{"title":"CentOS7防火墙Firewalld配置和使用","slug":"CentOS7防火墙Firewalld配置和使用","date":"2017-05-02T06:55:00.000Z","updated":"2018-01-24T15:13:45.000Z","comments":true,"path":"2017/05/02/CentOS7防火墙Firewalld配置和使用/","link":"","permalink":"http://www.seifon.cn/2017/05/02/CentOS7防火墙Firewalld配置和使用/","excerpt":"添加放行端口：1firewall-cmd --permanent --zone=public --add-port=80/tcp","text":"添加放行端口：1firewall-cmd --permanent --zone=public --add-port=80/tcp 删除放行端口：1firewall-cmd --permanent --zone=public --remove-port=80/tcp 热加载：1firewall-cmd --reload 命令含义：12345--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效 查看防火墙配置：1cat /etc/firewalld/zones/public.xml | less 查看防火墙状态1systemctl status firewalld.service 启动防火墙1systemctl start firewalld.service 关闭防火墙1systemctl stop firewalld.service 重新启动防火墙1systemctl restart firewalld.service","categories":[{"name":"Iptables","slug":"Iptables","permalink":"http://www.seifon.cn/categories/Iptables/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://www.seifon.cn/tags/centos/"},{"name":"linux","slug":"linux","permalink":"http://www.seifon.cn/tags/linux/"},{"name":"iptables","slug":"iptables","permalink":"http://www.seifon.cn/tags/iptables/"},{"name":"防火墙","slug":"防火墙","permalink":"http://www.seifon.cn/tags/防火墙/"}]},{"title":"出圈算法","slug":"出圈算法","date":"2017-04-12T16:58:00.000Z","updated":"2018-01-24T15:13:45.000Z","comments":true,"path":"2017/04/13/出圈算法/","link":"","permalink":"http://www.seifon.cn/2017/04/13/出圈算法/","excerpt":"","text":"题目：有 people 个人站成一个圈，第一个人开始数数（从1开始），每数到 num 或者 num 的倍数此人就退出。最后剩下的人是多少号？网上看了看，应该有很多种实现方法，在此摘录下来。 方式一：1234567static int cycle(int people, int num) &#123; int i, r = 0; for (i = 2; i &lt;= people; i++) &#123; r = (r + num) % i; &#125; return r + 1; &#125; 方式二：12345static int cycle(int people, int num) &#123; int i, r = 0; for (i = 2; i &lt;= people; i++) r = (r + num) % i; return r + 1; &#125; 方式三：1234567891011121314private static int cycle(int people, int num) &#123; List&lt;Integer&gt; dataList = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; people; i++) &#123; dataList.add(new Integer(i + 1)); &#125; int index = -1; while (dataList.size() &gt; 1) &#123; index = (index + num) % dataList.size(); dataList.remove(index); index--; &#125; return dataList.get(0).intValue(); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.seifon.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.seifon.cn/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.seifon.cn/tags/数据结构/"},{"name":"面试","slug":"面试","permalink":"http://www.seifon.cn/tags/面试/"}]}]}