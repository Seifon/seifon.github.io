<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用Filter和Spring拦截器，将用户信息动态传入Request方法]]></title>
    <url>%2F2018%2F04%2F21%2F%E5%88%A9%E7%94%A8Filter%E5%92%8CSpring%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E5%B0%86%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%8A%A8%E6%80%81%E4%BC%A0%E5%85%A5Request%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言： 在开发当中，我们经常会去验证用户登录状态和获取用户信息。如果每次都手动去调用用户信息查询接口，会非常的繁琐，为了提高开发效率，因此就有了今天这篇文章。 思路： 用户请求我们的方法会带上一个Token，我们可以自定义一个@Login注解，并在请求方法中接收一个MemberDeatails参数。然后我们通过过滤器和拦截器去获取用户信息，并传参给MemberDeatails 详细步骤：引入需要的Jar包：12 12345678@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Login &#123; String value() default &quot;&quot;;&#125; 2. 定义一个MemberDetails.class12345678910111213public class MemberDetails &#123; private String memberId; private String memberName; private String memberNickname; private String memberPhone; private String memberEmail;&#125; 12345678910/** * @Author: XiongFeng * @Description: 会员接口 * @Date: Created in 19:40 2018/4/10 */public interface MemberService &#123; /** 根据TokenId获取用户信息 */ MemberDto getMemberByToken(String token);&#125; 12345678910111213141516@Servicepublic class MemberServiceImpl implements MemberService &#123; @Override public MemberDetails getMemberDetailsByToken(String token) &#123; if (StringUtils.isBlank(token)) return null; if (!&quot;123&quot;.equals(token)) return null; MemberDetails memberDetails = new MemberDetails(); memberDetails.setMemberId(&quot;123&quot;); memberDetails.setMemberName(&quot;哈哈123&quot;); memberDetails.setMemberEmail(&quot;seifon@seifon.cn&quot;); memberDetails.setMemberNickname(&quot;Seifon&quot;); memberDetails.setMemberPhone(&quot;13100001111&quot;); return memberDetails; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.util.Date;import java.util.HashMap;import java.util.Map;/** * @Author: XiongFeng * @Description: 会员登录信息过滤器 * @Date: Created in 11:17 2018/4/13 */@Component@WebFilter(urlPatterns = &quot;/*&quot;)public class MemberFilter implements Filter &#123; MemberService memberService = new MemberServiceImpl(); ObjectMapper objectMapper = new ObjectMapper(); @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; String tokenId = req.getHeader(&quot;X-Authorization&quot;); if (tokenId == null || &quot;&quot;.equals(tokenId) || tokenId.isEmpty()) &#123; chain.doFilter(request, response); return; &#125; MemberDetails memberDetails = memberService.getMemberDetailsByToken(tokenId); if (memberDetails == null) &#123; try &#123; respFail(response); return; &#125; catch (Exception e) &#123; throw new ServletException(); &#125; &#125; Map&lt;String, String[]&gt; parameterMap = new HashMap&lt;String, String[]&gt;(request.getParameterMap()); parameterMap.put(&quot;memberId&quot;, new String[]&#123;memberDetails.getMemberId()&#125;); parameterMap.put(&quot;memberName&quot;, new String[]&#123;memberDetails.getMemberName()&#125;); parameterMap.put(&quot;memberEmail&quot;, new String[]&#123;memberDetails.getMemberEmail()&#125;); parameterMap.put(&quot;memberNickname&quot;, new String[]&#123;memberDetails.getMemberNickname()&#125;); parameterMap.put(&quot;memberPhone&quot;, new String[]&#123;memberDetails.getMemberPhone()&#125;); chain.doFilter(new ParameterRequestWrapper((HttpServletRequest) req, parameterMap), response); &#125; /** 返回失败结果Json数据 */ private void respFail(ServletResponse response) throws Exception &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;status&quot;, 500); map.put(&quot;message&quot;, &quot;登录失效，请登录&quot;); map.put(&quot;data&quot;, null); String s = objectMapper.writeValueAsString(map); response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json; charset=utf-8&quot;); response.getWriter().write(s); &#125; @Override public void destroy() &#123; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;import java.util.Vector;/** * @Author: XiongFeng * @Description: 对Request请求重新包装 * @Date: Created in 11:17 2018/4/13 */public class ParameterRequestWrapper extends HttpServletRequestWrapper &#123; private Map&lt;String , String[]&gt; params = new HashMap&lt;String, String[]&gt;(); @SuppressWarnings(&quot;unchecked&quot;) public ParameterRequestWrapper(HttpServletRequest request) &#123; // 将request交给父类，以便于调用对应方法的时候，将其输出，其实父亲类的实现方式和第一种new的方式类似 super(request); //将参数表，赋予给当前的Map以便于持有request中的参数 this.params.putAll(request.getParameterMap()); &#125; //重载一个构造方法 public ParameterRequestWrapper(HttpServletRequest request , Map&lt;String , Object&gt; extendParams) &#123; this(request); addAllParameters(extendParams);//这里将扩展参数写入参数表 &#125; /** * 复写获取key的方法 */ @Override public Enumeration getParameterNames() &#123; Vector names = new Vector(params.keySet()); return names.elements(); &#125; /** * 复写获取值value的方法 */ @Override public String getParameter(String name) &#123; Object v = params.get(name); if (v == null) &#123; return null; &#125; else if (v instanceof String[]) &#123; String[] strArr = (String[]) v; if (strArr.length &gt; 0) &#123; return strArr[0]; &#125; else &#123; return null; &#125; &#125; else if (v instanceof String) &#123; return (String) v; &#125; else &#123; return v.toString(); &#125; &#125; @Override public String[] getParameterValues(String name) &#123; Object v = params.get(name); if (v == null) &#123; return null; &#125; else if (v instanceof String[]) &#123; return (String[]) v; &#125; else if (v instanceof String) &#123; return new String[] &#123; (String) v &#125;; &#125; else &#123; return new String[] &#123; v.toString() &#125;; &#125; &#125; public void addAllParameters(Map&lt;String , Object&gt;otherParams) &#123;//增加多个参数 for(Map.Entry&lt;String , Object&gt;entry : otherParams.entrySet()) &#123; addParameter(entry.getKey() , entry.getValue()); &#125; &#125; public void addParameter(String name , Object value) &#123;//增加参数 if(value != null) &#123; if(value instanceof String[]) &#123; params.put(name , (String[])value); &#125;else if(value instanceof String) &#123; params.put(name , new String[] &#123;(String)value&#125;); &#125;else &#123; params.put(name , new String[] &#123;String.valueOf(value)&#125;); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.seifon.paymodle.interceptor;import cn.seifon.paymodle.annotations.Login;import cn.seifon.paymodle.dto.MemberDetails;import cn.seifon.paymodle.service.manager.member.MemberService;import cn.seifon.paymodle.service.manager.member.impl.MemberServiceImpl;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.core.MethodParameter;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Type;import java.util.HashMap;import java.util.Map;/** * @Author: XiongFeng * @Description: 会员登录信息拦截器 * @Date: Created in 11:17 2018/4/13 */public class MemberInterceptor extends HandlerInterceptorAdapter &#123; ObjectMapper objectMapper = new ObjectMapper(); MemberService memberService = new MemberServiceImpl(); public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HandlerMethod method = (HandlerMethod) handler; String[] memberIds = request.getParameterValues(&quot;memberId&quot;); MethodParameter[] methodParameters = method.getMethodParameters(); //判断方法类是否有MemberDetails入参 if (methodParameters.length &gt; 0) &#123; for (MethodParameter methodParameter : methodParameters) &#123; Type genericParameterType = methodParameter.getGenericParameterType(); String typeName = genericParameterType.getTypeName(); if (!typeName.equals(MemberDetails.class.getTypeName())) continue; if (memberIds == null || memberIds.length &lt;= 0) return this.respFail(response); //如果找不到用户信息就返回失败 break; &#125; &#125; //判断是否有Login注解 Login login = method.getMethodAnnotation(Login.class); if (login == null) return true; if (memberIds == null || memberIds.length &lt;= 0) return this.respFail(response); //如果找不到用户信息就返回失败 return true; &#125; /** 返回失败结果Json数据 */ private boolean respFail(HttpServletResponse response) throws Exception &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;status&quot;, 500); map.put(&quot;message&quot;, &quot;登录失效，请登录&quot;); map.put(&quot;data&quot;, null); String s = objectMapper.writeValueAsString(map); response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json; charset=utf-8&quot;); response.getWriter().write(s); return false; &#125;&#125; 12345678910111213141516@RestControllerpublic class MemberController &#123; @RequestMapping(&quot;/token&quot;) @Login public Map&lt;String, Object&gt; getUser(MemberDetails memberDetails) &#123; //User user = userManager.selectByPrimaryKey(id); Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;status&quot;, 200); map.put(&quot;message&quot;, &quot;请求成功&quot;); map.put(&quot;data&quot;, memberDetails); return map; &#125; &#125; 运行结果： 后记： 这篇文章只是记录了我的一点小小经验，如果有什么不对的地方或者有更好的方法，请大家在评论里留言指正！]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>拦截器</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx的五种负载算法模式]]></title>
    <url>%2F2017%2F09%2F05%2FNginx%E7%9A%84%E4%BA%94%E7%A7%8D%E8%B4%9F%E8%BD%BD%E7%AE%97%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1、轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 例如： 1234upstream bakend &#123; server 192.168.0.14; server 192.168.0.15; &#125; 2、weight权重指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如： 1234upstream bakend &#123; server 192.168.0.14 weight=10; server 192.168.0.15 weight=10; &#125; 3、ip_hash每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如： 12345upstream bakend &#123; ip_hash; server 192.168.0.14:88; server 192.168.0.15:80; &#125; 4、fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream backend &#123; server server1; server server2; fair; &#125; 5、url_hash（第三方）按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 123456upstream backend &#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32; &#125; tips: 1234567upstream bakend&#123;#定义负载均衡设备的Ip及设备状态 ip_hash; server 127.0.0.1:9090 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6060; server 127.0.0.1:7070 backup; &#125; 在需要使用负载均衡的server中增加 1proxy_pass http://bakend/; 每个设备的状态设置为: 1.down 表示单前的server暂时不参与负载 2.weight 默认为1.weight越大，负载的权重就越大。 3.max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 4.fail_timeout:max_fails次失败后，暂停的时间。 5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高CPU占用调优]]></title>
    <url>%2F2017%2F09%2F05%2F%E9%AB%98CPU%E5%8D%A0%E7%94%A8%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[根据top命令，发现PID为28555的Java进程占用CPU高达200%，出现故障。 通过查看进程1ps aux | grep PID 可以进一步确定是tomcat进程出现了问题。 但是，怎么定位到具体线程或者代码呢？ 首先显示线程列表:1ps -mp pid -o THREAD,tid,time 找到了耗时最高的线程28802，占用CPU时间快两个小时了！ 其次将需要的线程ID转换为16进制格式：1printf &quot;%x\n&quot; tid 最后打印线程的堆栈信息：1jstack pid |grep tid(16进制线程ID) –A60 找到有问题的java代码(省略)，进行业务调整和编码修改 最后，总结下排查CPU故障的方法和技巧有哪些： 1、top命令：Linux命令。可以查看实时的CPU使用情况。也可以查看最近一段时间的CPU使用情况。 2、PS命令：Linux命令。强大的进程状态监控命令。可以查看进程以及进程中线程的当前CPU使用情况。属于当前状态的采样数据。 3、jstack：Java提供的命令。可以查看某个进程的当前线程栈运行情况。根据这个命令的输出可以定位某个进程的所有线程的当前运行状态、运行代码，以及是否死锁等等。]]></content>
      <categories>
        <category>JAVA调优</category>
      </categories>
      <tags>
        <tag>调优</tag>
        <tag>Jstack</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开关指定端口，以80为例]]></title>
    <url>%2F2017%2F07%2F09%2F%E5%BC%80%E5%85%B3%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3%EF%BC%8C%E4%BB%A580%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[开启80端口：1iptables -I INPUT -p tcp --dport 80 -j ACCEPT 关闭80端口：1iptables -I INPUT -p tcp --dport 80 -j DROP 保存并重启Iptables：12/etc/init.d/iptables saveservice iptables restart]]></content>
      <categories>
        <category>Iptables</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>linux</tag>
        <tag>iptables</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins环境搭建]]></title>
    <url>%2F2017%2F07%2F08%2FJenkins%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[上传以下的包到/tmp/目录下：1234567891011jdk-8u121-linux-x64.tar.gzapache-tomcat-7.0.75.tar.gzapache-maven-3.5.0-bin.tar.gzMySQL-client-5.5.52-1.el6.x86_64.rpmMySQL-devel-5.5.52-1.el6.x86_64.rpmMySQL-server-5.5.52-1.el6.x86_64.rpmMySQL-shared-5.5.52-1.el6.x86_64.rpmgit-2.9.3.tar.gzjenkins.war 解压包到/opt/目录下：12345tar -xvzf /tmp/jdk-8u121-linux-x64.tar.gz -C /opt/tar -xvzf /tmp/apache-tomcat-7.0.75.tar.gz -C /opt/tar -xvzf /tmp/apache-maven-3.5.0-bin.tar.gz -C /opt/ 配置环境变量：12345678910111213vim /etc/profileJAVA_HOME=/opt/jdk1.8.0_121CATALINA_HOME=/opt/apache-tomcat-7.0.75MAVEN_HOME=/opt/apache-maven-3.5.0PATH=/opt/jdk1.8.0_121/bin:/opt/apache-tomcat-7.0.75/bin:/opt/apache-maven-3.5.0/bin:$PATHCLASSPATH=.:/opt/jdk1.8.0_121/lib/dt.jar:/opt/jdk1.8.0_121/lib/tools.jarexport JAVA_HOME PATH CLASSPATH CATALINA_HOME MAVEN_HOMEsource /etc/profile 配置Tomcat自启动： (1)、在/etc/init.d目录下创建文件：tomcat 内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/bin/bash# This is the init script for starting up the# Jakarta Tomcat server## chkconfig: 345 91 10# description: Starts and stops the Tomcat daemon.## Source function library.. /etc/rc.d/init.d/functions# Get config.. /etc/sysconfig/network# Check that networking is up.[ &quot;$&#123;NETWORKING&#125;&quot; = &quot;no&quot; ] &amp;&amp; exit 0export JAVA_HOME=/opt/jdk1.8.0_121export CATALINA_HOME=/opt/apache-tomcat-7.0.75startup=$CATALINA_HOME/bin/startup.shshutdown=$CATALINA_HOME/bin/shutdown.shstart()&#123; echo -n &quot;Starting Tomcat service:&quot; cd $tomcat_home $startup echo &quot;tomcat is succeessfully started up&quot;&#125;stop()&#123; echo -n &quot;Shutting down tomcat: &quot; cd $tomcat_home $shutdown echo &quot;tomcat is succeessfully shut down.&quot;&#125;status()&#123; numproc=`ps -ef | grep catalina | grep -v &quot;grep catalina&quot; | wc -l` if [ $numproc -gt 0 ]; then echo &quot;Tomcat is running...&quot; else echo &quot;Tomcat is stopped...&quot; fi&#125;restart()&#123; stop start&#125;# See how we were called.case &quot;$1&quot; instart) start ;;stop) stop ;;status) status ;;restart) restart ;;*) echo $&quot;Usage: $0 &#123;start|stop|status|restart&#125;&quot; exit 1esac (2)、配置权限，并加入自启： 1234cd /etc/init.dchmod 755 ./tomcatchkconfig --add tomcatchkconfig tomcat on (3)、设置URIEncoding=”UTF-8” 1vim /opt/apache-tomcat-7.0.75/conf/server.xml (4)、给Tomcat设置用户名密码 1234567vim /opt/apache-tomcat-7.0.75/conf/tomcat-users.xml&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;role rolename=&quot;manager-jmx&quot;/&gt;&lt;role rolename=&quot;manager-status&quot;/&gt;&lt;user username=&quot;tomcat_user&quot; password=&quot;123456&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status&quot; /&gt; (5)、打开/etc/sysconfig/iptables 加入以下代码： 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT (6)、重启防火墙服务 1service iptables restart 安装Mysql服务： 安装服务器端 1234rpm -ivh /tmp/MySQL-server-5.5.52-1.el6.x86_64.rpm如果出现报错就执行：rpm -e --nodeps mysql-libs-5.1.73-7.el6.x86_64 安装客户端 1rpm -ivh /tmp/MySQL-client-5.5.52-1.el6.x86_64.rpm 启动MySQL服务 1service mysql start 修改MySQL服务器登录密码 1/usr/bin/mysqladmin -u root password &apos;root&apos; 修改防火墙端口： 12345vim /etc/sysconfig/iptables-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPTservice iptables restart 修改MySQL服务器访问权限 第一步：登录MySQL服务器 第二步：use mysql; 第三步：查看user表部分内容 123456789101112mysql&gt; select host,user,password from user; +--------------+------+-------------------------------------------+ | host | user | password | +--------------+------+-------------------------------------------+ | localhost | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | computer0325 | root | | | 127.0.0.1 | root | | | ::1 | root | | | localhost | | | | computer0325 | | | +--------------+------+-------------------------------------------+ 6 rows in set (0.00 sec) 第四步：插入特定数据 1insert into user(host,user,password) values(&apos;%&apos;,&apos;root&apos;,&apos;*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B&apos;); 第五步：再次查看user表内容 123456789101112mysql&gt; select host,user,password from user; +--------------+------+-------------------------------------------+ | host | user | password | +--------------+------+-------------------------------------------+ | localhost | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | computer0325 | root | | | 127.0.0.1 | root | | | ::1 | root | | | localhost | | | | computer0325 | | | | % | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | +--------------+------+-------------------------------------------+ 第六步：为root@%授权 1mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION; 第七步：退出MySQL 1mysql&gt; exit; 第八步：重启MySQL服务 1service mysql restart; 编译安装git 安装依赖： 123yum install curl-devel expat-devel gettext-devel openssl-devel zlib-develyum install gcc perl-ExtUtils-MakeMaker 删除已有的git： 1yum remove git 编译git： 123456tar -xvzf ./git-2.9.3.tar.gz -C /opt/cd /opt/git-2.9.3/make prefix=/usr/local/git allmake prefix=/usr/local/git installecho &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrcsource /etc/bashrc 检查版本： 1git --version 部署Jenkins.war包，以及初始化环境：1cp /tmp/jenkins.war /opt/apache-tomcat-7.0.75/webapps/ 通过浏览器访问Tomcat下的jenkins应用 1例如：http://[server-address]:8080/jenkins/ 输入内置密钥串 先不安装插件，后面有需要时再安装，点右上角的× 修改默认管理员密码 安装GitHub plugin 和 Deploy to container Plugin 插件 点击系统管理，进入系统设置界面 Configure Global Security 123①勾选允许用户注册，这样万一我们忘记了之前的账号密码还可以再注册一个②勾选任何用户可以做任何事(没有任何限制)③取消防止跨站点请求伪造勾选 Global Tool Configuration ①设置Maven ②设置JDK，不要选自动安装，因为我们自己安装过了 ③设置MAVEN_HOME，同样不要自动安装 ④设置Git：/usr/local/git/bin/git]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yaml语法说明]]></title>
    <url>%2F2017%2F06%2F27%2FYaml%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[简介YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。 语法规则 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 ：冒号后面必须有空格 #表示注释，从这个字符一直到行尾，都会被解析器忽略。 YAML支持三种数据结构： 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 对象 一、对象的一组键值对，使用冒号结构表示。 1animal: pets 转为 JavaScript 如下： 1&#123; animal: &apos;pets&apos; &#125; 二、将所有键值对写成一个行内对象。 1hash: &#123; name: Steve, foo: bar &#125; 转为 JavaScript 如下 1&#123; hash: &#123; name: &apos;Steve&apos;, foo: &apos;bar&apos; &#125; &#125; 数组 一、一组连词线开头的行，构成一个数组。 123- Cat- Dog- Goldfish 转为 JavaScript 如下。 1[ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ] 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。 1234- - Cat - Dog - Goldfish 转为 JavaScript 如下。 1[ [ &apos;Cat&apos;, &apos;Dog&apos;, &apos;Goldfish&apos; ] ] 二、数组也可以采用行内表示法。 1animal: [Cat, Dog] 转为 JavaScript 如下。 1&#123; animal: [ &apos;Cat&apos;, &apos;Dog&apos; ] &#125; 复合结构 对象和数组可以结合使用，形成复合结构。 123456789languages: - Ruby - Perl - Python websites: YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 转为 JavaScript 如下： 123456&#123; languages: [ &apos;Ruby&apos;, &apos;Perl&apos;, &apos;Python&apos; ], websites: &#123; YAML: &apos;yaml.org&apos;, Ruby: &apos;ruby-lang.org&apos;, Python: &apos;python.org&apos;, Perl: &apos;use.perl.org&apos; &#125; &#125; 纯量 纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 字符串布尔值整数浮点数Null时间日期 数值直接以字面量的形式表示。 1number: 12.30 转为 JavaScript 如下。 1&#123; number: 12.30 &#125; 布尔值用true和false表示。 1isSet: true 转为 JavaScript 如下。 1&#123; isSet: true &#125; null用~表示。 1parent: ~ 转为 JavaScript 如下。 1&#123; parent: null &#125; 时间采用 ISO8601 格式。 1iso8601: 2001-12-14t21:59:43.10-05:00 转为 JavaScript 如下。 1&#123; iso8601: new Date(&apos;2001-12-14t21:59:43.10-05:00&apos;) &#125; 日期采用复合 iso8601 格式的年、月、日表示。 1date: 1976-07-31 转为 JavaScript 如下。 1&#123; date: new Date(&apos;1976-07-31&apos;) &#125; YAML 允许使用两个感叹号，强制转换数据类型。 12e: !!str 123f: !!str true 转为 JavaScript 如下。 1&#123; e: &apos;123&apos;, f: &apos;true&apos; &#125; 字符串 字符串是最常见，也是最复杂的一种数据类型。字符串默认不使用引号表示。 1str: 这是一行字符串 转为 JavaScript 如下。 1&#123; str: &apos;这是一行字符串&apos; &#125; 如果字符串之中包含空格或特殊字符，需要放在引号之中。 1str: &apos;内容： 字符串&apos; 转为 JavaScript 如下。 1str: &apos;内容: 字符串&apos; 单引号和双引号都可以使用，双引号不会对特殊字符转义。 12s1: &apos;内容\n字符串&apos;s2: &quot;内容\n字符串&quot; 转为 JavaScript 如下。 1&#123; s1: &apos;内容\\n字符串&apos;, s2: &apos;内容\n字符串&apos; &#125; 单引号之中如果还有单引号，必须连续使用两个单引号转义。 1str: &apos;labor&apos;&apos;s day&apos; 转为 JavaScript 如下。 1&#123; str: &apos;labor\&apos;s day&apos; &#125; 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。 123str: 这是一段 多行 字符串 转为 JavaScript 如下。 1&#123; str: &apos;这是一段 多行 字符串&apos; &#125; 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。 123456this: | Foo Barthat: &gt; Foo Bar 转为 JavaScript 代码如下。 1&#123; this: &apos;Foo\nBar\n&apos;, that: &apos;Foo Bar\n&apos; &#125; +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。 123456789s1: | Foos2: |+ Foos3: |- Foo 转为 JavaScript 代码如下。 1&#123; s1: &apos;Foo\n&apos;, s2: &apos;Foo\n\n\n&apos;, s3: &apos;Foo&apos; &#125; 字符串之中可以插入 HTML 标记。 1234message: | 段落 转为 JavaScript 如下。 123&#123; message: &apos;\n\n 段落\n\n&apos; &#125; 引用 锚点&amp;和别名*，可以用来引用。 1234567891011defaults: &amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &lt;&lt;: *defaultstest: database: myapp_test &lt;&lt;: *defaults 等同于下面的代码。 12345678910111213defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。 下面是另一个例子。 12345- &amp;showell Steve - Clark - Brian - Oren - *showell 转为 JavaScript 代码如下。 1[ &apos;Steve&apos;, &apos;Clark&apos;, &apos;Brian&apos;, &apos;Oren&apos;, &apos;Steve&apos; ] 函数和正则表达式的转换 这是 JS-YAML 库特有的功能，可以把函数和正则表达式转为字符串。 123# example.ymlfn: function () &#123; return 1 &#125;reg: /test/ 解析上面的 yml 文件的代码如下。 1234567891011var yaml = require(&apos;js-yaml&apos;);var fs = require(&apos;fs&apos;);try &#123; var doc = yaml.load( fs.readFileSync(&apos;./example.yml&apos;, &apos;utf8&apos;) ); console.log(doc);&#125; catch (e) &#123; console.log(e);&#125; 从 JavaScript 对象还原到 yaml 文件的代码如下。 1234567891011121314151617var yaml = require(&apos;js-yaml&apos;);var fs = require(&apos;fs&apos;);var obj = &#123; fn: function () &#123; return 1 &#125;, reg: /test/&#125;;try &#123; fs.writeFileSync( &apos;./example.yml&apos;, yaml.dump(obj), &apos;utf8&apos; );&#125; catch (e) &#123; console.log(e);&#125;]]></content>
      <categories>
        <category>Yaml</category>
      </categories>
      <tags>
        <tag>Yaml</tag>
        <tag>yml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql异地定时备份方法]]></title>
    <url>%2F2017%2F05%2F03%2FMysql%E5%BC%82%E5%9C%B0%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[两台linux服务器： 一台199.20.30.222（mysql服务器） 一台199.20.30.226（与mysql互通的一台server） 思路：mysql本地做一份备份；226Server做一份同步备份，脚本放在222上面，定时任务也设置在222上面。 （1）mysql本地备份：1234#!/bin/sh#mysql_backupDATE=`date +%Y%m%d`/opt/mysql/bin/mysqldump --opt jsweb -u root &gt; /opt/mysqlbackup/$DATE.sql （2）将本地备份同步到远端226上面：12345#!/bin/bash#date:2013/09/24#function:The script is used copying mysqlbackup to 226DATE=`date +%Y%m%d`scp /opt/mysqlbackup/$DATE.sql root@199.20.30.226:/data/2013backup/mysql/ （3）222上面设置定时任务：123vim/etc/crontable OR crontable -e30 1 * * * /bin/sh /home/jiaoben/backup.sh ===============每天1：30执行30 3 * * * /bin/sh /home/jiaoben/scp.sh ===============每天3：30执行 注意：两个linux之间相互拷贝文件，使用scp工具必须输入远端密码,所以在进行（2）时，需要规避输入密码，否则自动备份到remote不会生效, 本人采用的方法：使两个服务器互相信任，执行scp时，就可以免输入密码。 12345ssh-keygen -t rsacd /root/.ssh/scp id_rsa.pub root@199.20.30.226:/root/ssh/ssh root@199.20.30.226mv /root/.ssh/id_isa_pub /root/.ssh/authorized_key 时间过长备份的mysql就需要定时清理12find /opt/mysqlbackup/ -type f -name \*.sql -mtime +10 -exec rm -fr &#123;&#125; \;find /opt/mysqlbackup/ -type f -name &quot;*.sql&quot; -mtime +10 -exec rm -fr &#123;&#125; \;]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
        <tag>备份</tag>
        <tag>定时</tag>
        <tag>容灾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7防火墙Firewalld配置和使用]]></title>
    <url>%2F2017%2F05%2F02%2FCentOS7%E9%98%B2%E7%81%AB%E5%A2%99Firewalld%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[添加放行端口：1firewall-cmd --permanent --zone=public --add-port=80/tcp 删除放行端口：1firewall-cmd --permanent --zone=public --remove-port=80/tcp 热加载：1firewall-cmd --reload 命令含义：12345--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效 查看防火墙配置：1cat /etc/firewalld/zones/public.xml | less 查看防火墙状态1systemctl status firewalld.service 启动防火墙1systemctl start firewalld.service 关闭防火墙1systemctl stop firewalld.service 重新启动防火墙1systemctl restart firewalld.service]]></content>
      <categories>
        <category>Iptables</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>linux</tag>
        <tag>iptables</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出圈算法]]></title>
    <url>%2F2017%2F04%2F13%2F%E5%87%BA%E5%9C%88%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目：有 people 个人站成一个圈，第一个人开始数数（从1开始），每数到 num 或者 num 的倍数此人就退出。最后剩下的人是多少号？网上看了看，应该有很多种实现方法，在此摘录下来。 方式一：1234567static int cycle(int people, int num) &#123; int i, r = 0; for (i = 2; i &lt;= people; i++) &#123; r = (r + num) % i; &#125; return r + 1; &#125; 方式二：12345static int cycle(int people, int num) &#123; int i, r = 0; for (i = 2; i &lt;= people; i++) r = (r + num) % i; return r + 1; &#125; 方式三：1234567891011121314private static int cycle(int people, int num) &#123; List&lt;Integer&gt; dataList = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; people; i++) &#123; dataList.add(new Integer(i + 1)); &#125; int index = -1; while (dataList.size() &gt; 1) &#123; index = (index + num) % dataList.size(); dataList.remove(index); index--; &#125; return dataList.get(0).intValue(); &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
